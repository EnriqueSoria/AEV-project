
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="description" content="">
        <meta name="author" content="">
        <link rel="icon" href="imgs/favicon.png">

        <title>Nuestro juego</title>

        <!-- Bootstrap -->
        <link href="css/bootstrap.css" rel="stylesheet">
        <link href="css/bootstrap-theme.css" rel="stylesheet">
        <script src="js/bootstrap.min.js"></script>
        <script src="js/jquery-2.1.3.min.js"></script>

        <!-- Font-Awesome -->
        <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <!-- Slider
             https://github.com/codrops/Blueprint-FullWidthImageSlider
        -->
        <link rel="stylesheet" type="text/css" href="css/component.css" />
        <script src="js/modernizr.custom.js"></script>

        <!-- Google fonts -->
        <link href='http://fonts.googleapis.com/css?family=Raleway:100' rel='stylesheet' type='text/css'>
        <link href='http://fonts.googleapis.com/css?family=Anonymous+Pro' rel='stylesheet' type='text/css'>
        <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,300,700' rel='stylesheet' type='text/css'>
        <style>
            body {
                font-family: 'Open Sans', sans-serif;
            }
            a, p {
                font-size: 120%;
            }
            code {
                font-family: 'Anonymous Pro', serif;
            }
            a, p, h1, h2, h3, h4, h5, h6, ol, ul, li {
                font-weight: lighter;
            }
            .cd-container {
              width: 90%;
              max-width: 768px;
              margin: 2em auto;
            }
            .cd-container::after {
              /* clearfix */
              content: '';
              display: table;
              clear: both;
            }
            .cd-top.cd-is-visible {
              /* the button becomes visible */
              visibility: visible;
              opacity: 1;
            }
            .cd-top.cd-fade-out {
              /* if the user keeps scrolling down, the button is out of focus and becomes less visible */
              opacity: .5;
            }
            .wordWrap {
                word-wrap: break-word;      /* IE 5.5-7 */
                white-space: -moz-pre-wrap; /* Firefox 1.0-2.0 */
                white-space: pre-wrap;      /* current browsers */
            }
        </style>

        <!-- Unused fonts
        <link href='http://fonts.googleapis.com/css?family=Source+Code+Pro:300&subset=latin,latin-ext' rel='stylesheet' type='text/css'>
        -->

        <!-- back to top -->
        <style>
            .cd-top.cd-is-visible {
              /* the button becomes visible */
              visibility: visible;
              opacity: 1;
            }
            .cd-top.cd-fade-out {
              /* if the user keeps scrolling down, the button is out of focus and becomes less visible */
              opacity: .5;
            }
        </style>

        <!-- highlight.js -->
        <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/default.min.css">
        <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/highlight.min.js"></script>


    </head>

        <body>
        <!-- Fixed navbar -->
        <nav class="navbar navbar-default navbar-fixed-top">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              <a class="navbar-brand" href="./index.html">Chrome says</a>
            </div>
            <div id="navbar" class="navbar-collapse collapse">

              <!-- A la esquerra -->
              <ul class="nav navbar-nav">
                <li><a href="./index.html">Inici</a></li>
                <li><a href="./blog.html">Pràctiques</a></li>
                <li><a href="./memoria.html">Memòria</a></li>
                <li><a href="./about.html">Sobre...</a></li>
              </ul>

              <!-- A la dreta -->
              <ul class="nav navbar-nav navbar-right">
                <li><a href="https://github.com/EnriqueSoria/AEV-project/archive/master.zip"><i class="fa fa-download fa-lg"></i> Descarregar</a></li>
                <li><a href="https://github.com/EnriqueSoria/AEV-project"><i class="fa fa-github fa-lg"></i> Veure a github</a></li>
              </ul>
            </div>

          </div>
        </nav>


        <div class="container" style="margin-top: 75px;">


            <div class="text-center bg-alert">
                <h1>Chrome says</h1>
                <p class="lead">El joc és l'adaptació del clàssic “Simon says” a la consola Nintendo DS. No obstant, i per tal de dotar al projecte d'una mica de personalitat pròpia, canviarem el clàssic disc de quatre colors pel logotip del navegador Google Chrome, emprant els seus quatre colors com a tecles del disc.
                </p>
                <p>
                    <a href="https://github.com/EnriqueSoria/AEV-project" class="btn btn-lg btn-info"><i class="fa fa-github fa-lg"></i>  Veure a Github</a>
                    <a href="https://github.com/EnriqueSoria/AEV-project/archive/master.zip" class="btn btn-lg btn-success btn-succes"><i class="fa fa-download fa-lg"></i>  Descarregar</a>
                </p>
            </div>


            <br><hr><br>



<!-- Cuerpo -->
<div id="sidebar" class="row jumbotron">

    <!-- Indice -->
    <div class="col-md-8">
        
    <h1 class="text-muted" >Taula de continguts</h1>
    <ol>
        <li><h4><bold><a href='#abstracte'>Abstracte</a></bold><h4></li>

<li><h4><bold><a href='#objectius'>Objectius</a></bold><h4></li>

<li><h4><bold><a href='#introduccio'>Introduccio</a></bold><h4></li>

<li><h4><bold><a href='#desenvolupament'>Desenvolupament</a></bold><h4></li>

<li><h4><bold><a href='#conclusio'>Conclusio</a></bold><h4></li>

<li><h4><bold><a href='#bibliografia'>Bibliografia</a></bold><h4></li>


    </ol>

    </div>
</div>
<div class="row">
    <!-- Aquí empiezan los artículos -->
    <div class="col-md-12">
        
    <div id='abstracte' class='featurette data-sr'>
        <h2>1. Abstracte</h2>
<p><strong>Chrome</strong> says és un videojoc que correspon amb el projecte final de l’assignatura AEV (ETSINF - UPV).</p>
<p>Desenvolupat mitjançant la biblioteca vista a classe <code>libnds</code> i el llenguatge de programació C, el joc consisteix en tocar els botons il·luminats per la màquina en el mateix ordre, fins arribar a quinze seqüències, sense que s’acabe el temps. Tot tenint   en compte que les possibles errades de repetiment per part de l’usuari descomptaran     segons al compte enrere, reduint el temps per completar el joc.</p>
<p>Deixant de banda les mecàniques, el joc és una adaptació del clàssic “Simon says” a l’univers Google y a la videoconsola Nintendo DS. Aquesta memòria documentarà tot el procés de desenvolupament del videojocs des de les seues primeres fases.</p>
<p><strong>Paraules clau</strong>: <code>Nintendo DS</code>, <code>Chrome</code>, <code>Simon</code>, <code>videojoc</code>, <code>libnds</code>.</p>
    </div>
<br><hr><br>

    <div id='objectius' class='featurette data-sr'>
        <h2>2. Objectius</h2>
<p>El principal objectiu d’aquest projecte és ser capaços de desenvolupar un videojoc complet, partint de zero, per a la videoconsola <code>Nintendo DS</code> posant en  pràctica tots els coneixements apresos al llarg de l’assignatura: tractament d’imatges, àudio, interacció entrada/sortida amb l’usuari, etc.</p>
<p>Altre objectiu és el contingut pedagògic d’aquesta pròpia memòria. Lluny de     ser un tutorial, aquest document explica els passos seguits pels autors per tal d’assolir l’objectiu principal abans esmentat. Així, aquest document ajudarà  a futurs alumnes que es troben els mateixos problemes que els autors a l’hora de desenvolupar el seu projecte de l’assignatura.</p>
    </div>
<br><hr><br>

    <div id='introduccio' class='featurette data-sr'>
        <h2>3. Introducció</h2>
<h3>3.1 Argument</h3>
<p>El nostre navegador s’ha tornat boig. En un acte d’extrema maldat , <em>Google Chrome</em> ha decidit enviar el nostre historial de navegació a la nostra mare. Per tal d’impedir-nos evitar-ho, ha bloquejat el nostre ordinador, si volem evitar la catàstrofe, tindrem que seguir el joc al malvat <em>Chrome</em> i seguir les combinacions de colors que ens diga. Per fer-ho encara més complicat, Chrome només ens dóna un minut per tal de fer les quinze combinacions que ens mostra. Si aconseguim fer-ho abans de que s’acabe el temps, esborrarem amb èxit el nostre historial i recuperarem el control del nostre ordinador. Però si no ho fem... ningú pot imaginar-se les conseqüències.</p>
<h3>3.2 Partida tipus</h3>
<p>Només comence el joc es mostrarà el menú principal. L’única opció serà la de començar un nou joc, però mentre no se li’n done a la pantalla tàctil al botó o es prema el botó A, no s’iniciarà la partida. Es podrà sentir el tema principal del joc des de’l primer moment, sense necessitat d’haver iniciat la partida.</p>
<p>Una vegada iniciada, a la pantalla superior començarà el compte enrere, mentre que a la inferior començarà la primera seqüència de colors, il·luminant-se les tecles corresponent. Cada vegada que s’il·lumine una tecla del disc Chrome a la pantalla inferior, ja siga perquè l’usuari l’ha pressionat o la pròpia màquina ho ha fet, s’escoltarà un so corresponent al color en qüestió. Una vegada acabe la màquina, el jugador tindrà control per a poder repetir la seqüència. Si encerta, sumarà dos segons al compte enrere, i continuarà la màquina afegint una tecla més a la seqüència. Si falla, es restarà un segon al compte enrere, a més d’emetre’s un so característic que indica l’error. En cas de fallada de l’usuari, no s’afegirà una altra tecla a la seqüència fins que es faça bé.</p>
<p>Una vegada el jugador guanye, o perda, es donarà pas a la pantalla de victòria o de derrota, respectivament. L’única interacció possible serà donar-li al botó de la pantalla inferior, o prémer el botó A per tal de tornar al menú principal.</p>
<p><img class="img-responsive center-block" alt="Figura 1: Diagrama de flux d'una partida tipus" src="imgs/memoria/1.png" /></p>
<h3>3.3 Motivació</h3>
<p>Obviant el desig de voler treure la millor nota possible a l’assignatura, hi ha altra motivació oculta, per part dels autors, que explica la tria d’aquest projecte. I aquesta és l’aspiració d’entrar a formar per de la indústria dels videojocs com a desenvolupadors dels mateixos.</p>
<p>És per tant, per tal d’assolir aquest objectiu, un requisit indispensable tenir una bona base amb els mateixos. Així com disposar d’alguns jocs fets prèviament per tal de fer-los servir com a carta de presentació i mostra de les aptituds personals dels autors a l’hora de fer la seua feina. És aquesta, per tant, la raó d’haver-nos matriculat d’aquesta assignatura i haver-hi seleccionat aquest projecte entre els proposats pel professor.</p>
    </div>
<br><hr><br>

    <div id='desenvolupament' class='featurette data-sr'>
        <h2>4. Desenvolupament</h2>
<h3>4.1 Coneixements previs</h3>
<p>Anem a veure a continuació els coneixements previs indispensables per tal de poder desenvolupar aquest projecte:</p>
<ul>
<li>Nivell intermedi, o superior, del llenguatge de programació C</li>
<li>Conèixer l’arquitectura de la videoconsola <em>Nintendo DS</em></li>
</ul>
<p>Com podem veure, només hi ha dos requisits previs per tal de poder fer aquesta aplicació, ja que és un projecte molt simple no necessitem més, però també seria recomanable, per tal de fer més fàcil la nostra tasca i fer un joc de millor qualitat, tenir els següents coneixements:</p>
<ul>
<li>Coneixement de retoc fotogràfic (GIMP, Photoshop, etc)</li>
<li>Coneixement de creació de música i efectes (Audacity, etc)</li>
</ul>
<p>El motiu d’aquests coneixements recomanables és per tal de poder editar i produir les nostres pròpies <em>backgrounds</em>, <em>sprites</em>, y <em>textures</em>. Així com els efectes de so i àudios. Tot açò es pot trobar per internet amb llicències obertes i sense restriccions, però amb açò perdrem la personalitat del projecte i dependrem de contingut de tercers. No obstant, es pot fer sense tenir aquestes nocions.</p>
<p>Per acabar aquest punt, llistarem a continuació el programari necessari per tal de desenvolupar el projecte i, entre parèntesi, el que nosaltres hem utilitzat. Òbviament no té per què emprar-se el mateix que nosaltres:</p>
<ul>
<li>Editor de text o IDE: <code>Notepad</code>, <code>Gedit</code></li>
<li>Emulador de <em>Nintendo DS</em>: <code>No$GBA</code>, <code>DeSmuME</code></li>
</ul>
<h3>4.2 Procediment utilitzat</h3>
<p>Per al desenvolupament de <strong>Chrome says</strong> hem seguit el cicle de desenvolupament del programari i les seues fases.</p>
<p><img class="img-responsive center-block" alt="Figura 2: Fases de desenvolupament del programari" src="imgs/memoria/2.png" /></p>
<h4>4.2.1 Requisits</h4>
<p>Com que ja hem explicat a la introducció com és una partida tipus, ja sabem quins són, doncs, els requisits. Així doncs, anem a llistar-los per tal de deixar-ho el més clar possible:</p>
<ul>
<li>Menús principal, de victòria i derrota</li>
<li>Compte enrere amb la possibilitat de sumar o restar segons</li>
<li>Intel·ligència artificial que genere seqüències de colors</li>
<li>Capacitat d’interacció per part de l’usuari</li>
<li>Il·luminació de tecles i sons</li>
<li><em>Backgrounds</em> i <em>sprites</em></li>
<li>Un so per a cada tecla, a més d’un so de selecció, d’error i un tema principal per al joc</li>
</ul>
<p>Una vegada tenim tots els requisits clars, cal que passem a analitzar com solucionar el nostre problema (requisits), això és, la fase de l’anàlisi.</p>
<h4>4.2.2 Anàlisi</h4>
<p>L’anàlisi no és altra cosa que la solució als problemes plantejats als requisits. Així doncs, anem a veure quina va ser la nostra solució per a cadascun d’aquests problemes sense entrar en temes de programació, punt que veurem a la fase de codificació.</p>
<p>Tots els menús s’implementen amb el seu codi a part, cada menú tindrà la seua pròpia funció, llevat del de victòria i derrota que tindrà la mateixa i, depenent de l’argument d’entrada, es carregarà un o altre menú. Com que només cal carregar dues backgrounds i definir una interacció quan es prem el botó de la pantalla o la tecla A, és una funció molt simple.</p>
<p>El compte enrere s’implementarà mitjançant dues funcions: una que actualitze el temporitzador cada segon i vaja descomptant, i altra que, segons si l’usuari falla o encerta la combinació a repetir, sume o reste la quantitat corresponent al temporitzador (dos segons en cas d’encert i un en cas de fallada).</p>
<p>La intel·ligència artificial és un punt fàcil de resoldre. Una simple funció que traga valors aleatoris entre quatre possibilitats ens servirà per tal de saber quina tecla té que il·luminar-se. Guardarem aquesta combinació per tal se saber quina és la solució correcta que l’usuari té que repetir i així poder comprovar si ho ha fet bé o no.</p>
<p>Per a cada tecla o botó, en el cas de la interfície del menú, definirem unes regions a les quals detectarem si l’usuari ha polsat. Ja que tota interacció es farà mitjançant la pantalla inferior o tàctil. Amb aquestes regions de coordenades podrem saber quina tecla ha polsat l’usuari en cada moment, informació que enviarem a la funció d’il·luminació i a la de comprovació de solució.</p>
<p>La funció d’il·luminació i sons carregarà la background corresponent a la tecla il·luminada i reproduirà el seu so característic. Aquesta funció s’empra tant per la intel·ligència artificial com per la part de la interacció de l’usuari. D’aquesta manera ens estalviem el tenir que fer dues funcions separades per al mateix propòsit.</p>
<p>La creació de les diferents backgrounds i sprites que es gasten al joc s’han fet amb el programari lliure GIMP. Al subapartat de disseny veurem com les hem distribuït. De la mateixa manera, el so s’ha tret íntegrament de les pàgines indicades ala bibliografia sense que nosaltres el modifiquem de cap manera.</p>
<p>Tota la integració d’aquestes funcions es fa al mètode principal main del joc. Una vegada hem analitzat els problemes i pensat una solució, només cal fer el disseny i començar a codificar les funcions ací descrites.</p>
<h4>4.2.3 Disseny</h4>
<p>Pel que fa al disseny d’interfícies, ho hem fet de la manera més simple que hem pogut. Reduint al mínim la sobrecàrrega d’informació, l’usuari sempre sabrà què fer i on polsar per tal de continuar amb la seua tasca. Els menús són simples i el joc també.</p>
<p><img class="img-responsive center-block" alt="Figura 3: Menú principal del joc" src="imgs/memoria/3.png" /></p>
<p>Centrem sempre la interacció en la pantalla tàctil, de manera que resulte més còmode per a l’usuari acostumar-se a que la pantalla superior tan sols és informativa. D’aquesta manera estarà centrat en la pantalla inferior per tal d’interaccionar i mirarà la superior per a consultar informació, com ara, el temporitzador per a saber quant de temps li queda.</p>
<p><img class="img-responsive center-block" alt="Figura 4: Pantalla inferior quan es prem la tecla roja" src="imgs/memoria/4.png" /></p>
<h4>4.2.4 Codificació</h4>
<p>La part de codificació consisteix, com ja hem dit, en passar a codi la part de l’anàlisi. Així doncs, passem a explicar breument, ja que junt amb la memòria s’entregarà el codi del projecte, les funcions que hem detallat a l’anàlisi de manera abstracta.</p>
<p><strong>Menús</strong>: Els menús no són més que backgrounds que es carreguen i mostren en la consola. Les funcions dels menús es queden en un bucle del qual només es surt quan l’usuari prem el botó de la pantalla tàctil o la tecla A. Com ja hem explicat a l’anàlisi, per tal de detectar quan s’ha pressionat el botó de la pantalla tàctil, s’ha delimitat una superfície de coordenades a la pantalla. Quan l’usuari toca la pantalla dins d’eixa superfície, se sap que ha pres el botó.</p>
<p><strong>Compte enrere</strong>: Per al compte enrere s’han fet les dues funcions abans dites. Ambdues gastes unes variables globals que indiquen els minuts i segons del temporitzador, i són eixes variables les que anem actualitzant. Per a anar reduint una vegada per segon el temps, es gasta un dels temporitzadors hardware dels que disposa la consola. A aquest temporitzador li indiquem que cride a la funció d’actualitzar, una vegada per segon. D’aquesta manera podem reduir el temps d’una manera simple.</p>
<p><img class="img-responsive center-block" alt="Figura 5: Línia de codi del temporitzador hardware número 9" src="imgs/memoria/5.png" /></p>
<p><strong>Intel·ligència artificial</strong>: Per a la intel·ligència artificial hem tingut més problemes, ja que a C les funcions <code>rand()</code> generen números pseudoaleatoris, però sempre basades en una mateixa seed. Aleshores, mentre aquesta seed no es modifique, cada partida sortirien els mateixos números, i per tant, la mateixa combinació de tecles a polsar. La solució va ser declarar una variable qualsevol, traure la seua adreça virtual, la qual canviarà en cada execució del programa font, i, per tal de donar-li més aleatorietat, li sumem els segons actuals del compte enrere (el qual, òbviament, es modifica a cada segon que passa) i aquest valor serà la seed per a eixe valor aleatori. Per al següent, es tornarà a fer el procés per a canviar la seed i després es traurà el valor, de manera que cada valor està tret d’una llavor diferent.</p>
<p><img class="img-responsive center-block" alt="Figura 6: Funció per traure un sencer pseudoaleatori canviant la seed cada execució" src="imgs/memoria/6.png" /></p>
<p>Després, amb altra funció, canviem eixe sencer tret amb la funció anterior per un caràcter que ens indicarà quina tecla surt per a la combinació.</p>
<p><strong>Interacció</strong>: La interacció és la part més simple, només tenim que veure qualsevol dels exemples que ens proporciona devKitPro per a veure que simplement hi ha que indicar una variable <code>touchPosition</code> que ens indicarà les coordenades a les que s’ha tocat la pantalla tàctil cada vegada que es faça. Amb això i les regions o superfícies delimitades per a cada tecla, sabrem si s’ha polsat dins d’una tecla o no i, en cas d’haver-ho fet, quina és.</p>
<p><strong>Il·luminació i sons</strong>: Per a la il·luminació de les tecles, simplement hem fet una <em>background</em> per a cada possible tecla il·luminada. Aleshores, només ens cal una funció que, depenent de l’entrada, carregue un o altre fons. Tornant després al fons original, és a dir, sense cap tecla il·luminada. Amb aquesta mateixa entrada, podrem indicar de la mateixa forma quin so es té que reproduir. Llevat del tema principal que es comença a reproduir al començament de l’execució del programa, indistintament de la interacció de l’usuari.</p>
<p><img class="img-responsive center-block" alt="Figura 7: Funció per a &quot;il·luminar&quot; la tecla corresponent" src="imgs/memoria/7.png" /></p>
<p>Explicats aquests punts fonamentals, la resta del codi consisteix bàsicament en la integració de totes aquestes parts. Com s’adjunta el codi, es pot mirar qualsevol funció i consultar-la.</p>
<h4>4.5.2 Proves</h4>
<p>Malgrat ser l’última fase, a aquest projecte les proves s’han anat fent segons es desenvolupava la fase de codificació pas a pas, per tal d’anar veient que tot funcionava correctament. Les proves finals han sigut en ambdós emuladors per tal de veure que funcionava indistintament en un i altre.</p>
    </div>
<br><hr><br>

    <div id='conclusio' class='featurette data-sr'>
        <h2>5. Conclusió</h2>
<p>Com a conclusions d’aquest treball podem treure la gran necessitat d’una millor documentació de libnds. Per als dubtes que han anat sortint al llarg del desenvolupament: cerca de funcions, macros, estructures... s’han tingut que consultar els exemples que vénen amb el devKitPro, ja que la documentació era confusa en ocasions.</p>
<p><img class="img-responsive center-block" alt="Figura 8: Part de la documentació oficial de libnds" src="imgs/memoria/8.png" /></p>
<p>Com a treball de l’assignatura és un projecte acceptable. A més a més, com que cada alumne pot triar quin fer o inclús proposar un, és molt versàtil. No obstant, s’hauria de donar més pràctica a classe. A les classes de teoria s’haurien de dur portàtils o fer-les al laboratori, el mestre hauria de anar guiant des del seu tota la sessió, mostrant com carregar imatges, sons, etc. Per tal d’ajudar l’aprenentatge dels alumnes.</p>
<p>També, i com a conclusió final, hem consolidat les fases de desenvolupament del programari, així com els coneixements adquirits a classe sobre l’arquitectura de la Nintendo DS. Sobre la qual, pensem, que seria necessari desenvolupar un framework per tal de fer més fàcil la tasca de programar sobre ella. Ja que no és difícil però es fa pesat i pot arribar a ser enutjós. Més encara quan no hi ha una bona documentació al darrere.</p>
    </div>
<br><hr><br>

    <div id='bibliografia' class='featurette data-sr'>
        <h2>6. Biblioteca</h2>
<h3>6.1 Material de consulta</h3>
<p>[1] Documentació de libnds. Disponible en:
http://libnds.devkitpro.org/index.html</p>
<p>[2] <em>How to make a bouncing ball game</em>. Disponible en:
http://ekid.nintendev.com/bouncy/</p>
<p>[3] Pràctiques de l’assginatura d’AEV, ETSINF-UPV.</p>
<p>[4] Dubtes de programació sobre C resolts als fòrums d’Stackoverflow. Disponible en:
http://stackoverflow.com/</p>
<h3>6.2 Imatges i sons</h3>
<p>[1] Find Icons. Disponible en:
http://findicons.com/</p>
<p>[2] Homes Kid. Disponible en:
http://homes-kid.com/</p>
<p>[3] Free Sound. Disponible en:
http://freesound.org/</p>
<p>[4] The ModArchive. Disponible en:
http://modarchive.org/</p>
    </div>
<br><hr><br>

    </div>
</div>

<!-- Pie de página -->

        
        <!-- Highlighter -->
        <script>hljs.initHighlightingOnLoad();</script>
        
        <!-- Sidebar -->
        <script>
            var $sidebar   =    $("#sidebar"),
            $window    = $(window),
            offset     = $sidebar.offset(),
            topPadding = 15;

        $window.scroll(function() {
            if ($window.scrollTop() > offset.top) {
                $sidebar.addClass('fixed');
            } else {
                $sidebar.removeClass('fixed');
            }
        });
        </script>
        
        <!-- Back to top -->
        <script>
                jQuery(document).ready(function($){
	        // browser window scroll (in pixels) after which the "back to top" link is shown
	        var offset = 300,
		        //browser window scroll (in pixels) after which the "back to top" link opacity is reduced
		        offset_opacity = 1200,
		        //duration of the top scrolling animation (in ms)
		        scroll_top_duration = 700,
		        //grab the "back to top" link
		        $back_to_top = $('.cd-top');

	        //hide or show the "back to top" link
	        $(window).scroll(function(){
		        ( $(this).scrollTop() > offset ) ? $back_to_top.addClass('cd-is-visible') : $back_to_top.removeClass('cd-is-visible cd-fade-out');
		        if( $(this).scrollTop() > offset_opacity ) { 
			        $back_to_top.addClass('cd-fade-out');
		        }
	        });

	        //smooth scroll to top
	        $back_to_top.on('click', function(event){
		        event.preventDefault();
		        $('body,html').animate({
			        scrollTop: 0 ,
		         	}, scroll_top_duration
		        );
	        });

        });
        </script>
        
        <!-- Slider
             https://github.com/codrops/Blueprint-FullWidthImageSlider
        -->
        <script src="js/jquery.cbpFWSlider.min.js"></script>
        <script>
            $( function() {
                $( '#cbp-fwslider2' ).cbpFWSlider();
            } );
            
            $( function() {
                $( '#cbp-fwslider3' ).cbpFWSlider();
            } );
        </script>

        <a href="#0" class="cd-top">Top</a>
    </body>
</html>
